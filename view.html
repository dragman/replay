<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chat Replay</title>
  <style>
    /* Basic page setup */
    body {
      margin: 0;
      padding: 0;
      background: #111827;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .phone-frame {
      width: 400px;
      height: 720px;
      background: #020617;
      border-radius: 24px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border: 2px solid #1e293b;
    }

    .top-bar {
      height: 54px;
      background: linear-gradient(90deg, #0f172a, #020617);
      display: flex;
      align-items: center;
      padding: 0 16px;
      color: #e5e7eb;
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 1px 0 rgba(15, 23, 42, 0.8);
      letter-spacing: 0.02em;
    }

    .top-bar .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      margin-right: 8px;
      background: #22c55e;
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.7);
    }

    .chat-window {
      flex: 1;
      padding: 14px 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow-y: hidden; /* we'll scroll with JS */
      background: radial-gradient(circle at top, #0b1120 0, #020617 50%, #000 100%);
    }

    .bubble-row {
      display: flex;
      width: 100%;
      margin-bottom: 2px;
    }

    .bubble-row.them {
      justify-content: flex-start;
    }

    .bubble-row.me {
      justify-content: flex-end;
    }

    .bubble {
      max-width: 70%;
      padding: 8px 10px;
      border-radius: 16px;
      font-size: 13px;
      line-height: 1.35;
      position: relative;
      opacity: 0;
      transform: translateY(4px) scale(0.98);
      animation: bubbleIn 0.25s ease-out forwards;
    }

    .bubble.them {
      background: rgba(15, 23, 42, 0.95);
      color: #e5e7eb;
      border-bottom-left-radius: 4px;
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.6);
    }

    .bubble.me {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #052e16;
      border-bottom-right-radius: 4px;
      box-shadow: 0 4px 10px rgba(21, 128, 61, 0.5);
    }

    .control-bar {
      background: #030712;
      border-bottom: 1px solid rgba(15, 23, 42, 0.8);
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: #cbd5f5;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .control-bar label {
      opacity: 0.75;
    }

    .control-bar input[type="date"] {
      flex: 1;
      background: #0f172a;
      color: #e2e8f0;
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 999px;
      padding: 5px 12px;
      font-size: 12px;
      appearance: none;
    }

    .sender {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 2px;
      opacity: 1;
      color: rgba(248, 250, 252, 0.95);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.45);
    }

    .bubble.me .sender {
      color: #064e3b;
      text-shadow: none;
    }

    .time {
      font-size: 10px;
      opacity: 0.6;
      margin-top: 2px;
      text-align: right;
    }

    @keyframes bubbleIn {
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .bottom-bar {
      height: 40px;
      border-top: 1px solid rgba(15, 23, 42, 0.85);
      background: #020617;
      display: flex;
      align-items: center;
      padding: 0 14px;
      font-size: 11px;
      color: #4b5563;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .rec-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #f97316;
      margin-right: 8px;
      box-shadow: 0 0 10px rgba(249, 115, 22, 0.7);
    }

    /* Optional subtle vignette */
    .vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 80px rgba(0, 0, 0, 0.9);
      border-radius: 24px;
    }
  </style>
</head>
<body>
  <div class="phone-frame">
    <div class="top-bar">
      <div class="dot"></div>
      <span>First Messages ¬∑ Replay</span>
    </div>
    <div class="control-bar">
      <label for="dateInput">Jump to date</label>
      <input type="date" id="dateInput" />
    </div>
    <div id="chat" class="chat-window"></div>
    <div class="bottom-bar">
      <div class="rec-dot"></div>
      <span>Chat playback</span>
    </div>
    <div class="vignette"></div>
  </div>

  <script>
    const MY_NAME = "Dragos"; // Change if you want a different sender marked as "me"
    const FALLBACK_MESSAGES = [
      {
        sender: "You",
        fromMe: true,
        text: "Hey, I finally exported the WhatsApp chat.",
        time: "09:12",
        date: "01/01/2020"
      },
      {
        sender: "Them",
        fromMe: false,
        text: "No way üòÇ how far back does it go?",
        time: "09:13",
        date: "01/01/2020"
      },
      {
        sender: "You",
        fromMe: true,
        text: "All the way to the very first awkward message.",
        time: "09:13",
        date: "01/01/2020"
      },
      {
        sender: "Them",
        fromMe: false,
        text: "We definitely don't talk about those.",
        time: "09:14",
        date: "01/01/2020"
      }
    ];

    const chatEl = document.getElementById("chat");
    const dateInputEl = document.getElementById("dateInput");
    let index = 0;
    let playbackMessages = FALLBACK_MESSAGES;
    let allMessages = FALLBACK_MESSAGES;
    let currentKeyParam = "";
    const senderColors = {};
    const COLOR_PALETTE = [
      "#1d4ed8",
      "#7c3aed",
      "#db2777",
      "#f97316",
      "#0ea5e9",
      "#eab308",
      "#10b981",
      "#ec4899"
    ];
    let colorPointer = 0;

    function base64ToBytes(b64) {
      const binary = atob(b64);
      const out = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        out[i] = binary.charCodeAt(i);
      }
      return out;
    }

    function base32ToBytes(str) {
      if (!str) throw new Error("Missing key in URL hash");
      const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
      const clean = str.replace(/=+$/g, "").toUpperCase();
      let buffer = 0;
      let bitsLeft = 0;
      const out = [];

      for (const ch of clean) {
        const val = alphabet.indexOf(ch);
        if (val === -1) throw new Error("Invalid Base32 character");
        buffer = (buffer << 5) | val;
        bitsLeft += 5;
        if (bitsLeft >= 8) {
          bitsLeft -= 8;
          out.push((buffer >> bitsLeft) & 0xff);
        }
      }

      return new Uint8Array(out);
    }

    function getParamValue(name) {
      const searchValue = new URLSearchParams(window.location.search).get(name);
      if (searchValue) return searchValue;
      const hash = location.hash.startsWith("#") ? location.hash.slice(1) : location.hash;
      const hashValue = new URLSearchParams(hash).get(name);
      return hashValue;
    }

    function normalizeDateInput(value) {
      if (!value) return null;
      const trimmed = value.trim();
      if (/^(\d{2})\/(\d{2})\/(\d{4})$/.test(trimmed)) {
        return trimmed;
      }
      const isoMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (isoMatch) {
        const [, year, month, day] = isoMatch;
        return `${day}/${month}/${year}`;
      }
      return null;
    }

    function applyDateFilter(messages, normalizedDate) {
      if (!normalizedDate) {
        return messages;
      }
      const startIndex = messages.findIndex((msg) => msg.date === normalizedDate);
      if (startIndex === -1) {
        console.warn(`No messages found for date ${normalizedDate}`);
        return messages;
      }
      return messages.slice(startIndex);
    }

    function normalizedToISO(dateStr) {
      if (!dateStr) return "";
      const [day, month, year] = dateStr.split("/");
      if (!day || !month || !year) return "";
      return `${year}-${month.padStart(2, "0")}-${day.padStart(2, "0")}`;
    }

    function populateDatePicker(messages, selectedDate) {
      if (!dateInputEl) return;
      const dates = Array.from(
        new Set(
          messages
            .map((msg) => msg.date)
            .filter(Boolean)
        )
      );
      dates.sort((a, b) => {
        const [dayA, monthA, yearA] = a.split("/").map(Number);
        const [dayB, monthB, yearB] = b.split("/").map(Number);
        return new Date(yearA, monthA - 1, dayA) - new Date(yearB, monthB - 1, dayB);
      });

      if (dates.length) {
        const min = normalizedToISO(dates[0]);
        const max = normalizedToISO(dates[dates.length - 1]);
        dateInputEl.min = min;
        dateInputEl.max = max;
      }

      dateInputEl.value = selectedDate ? normalizedToISO(selectedDate) : "";
    }

    function handleDateInputChange() {
      if (!dateInputEl) return;
      const isoValue = dateInputEl.value;

      const params = new URLSearchParams();
      if (currentKeyParam) {
        params.set("K", currentKeyParam);
      }
      if (isoValue) {
        params.set("D", isoValue);
      }
      const paramString = params.toString();
      location.hash = paramString ? paramString : "";
      window.location.reload();
    }

    if (dateInputEl) {
      dateInputEl.addEventListener("change", handleDateInputChange);
    }

    async function loadMessages() {
      try {
        const keyB32 = getParamValue("K");
        const dateFilterRaw = getParamValue("D");
        const normalizedDate = normalizeDateInput(dateFilterRaw);
        if (dateFilterRaw && !normalizedDate) {
          console.warn("Invalid date filter. Use DD/MM/YYYY or YYYY-MM-DD.");
        }
        currentKeyParam = keyB32 || "";
        const keyBytes = base32ToBytes(keyB32);

        const response = await fetch("chat_data.enc");
        if (!response.ok) {
          throw new Error(`Failed to fetch chat_data.enc (${response.status})`);
        }
        const enc = await response.json();
        const nonce = base64ToBytes(enc.nonce);
        const ciphertext = base64ToBytes(enc.ciphertext);

        const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, "AES-GCM", false, ["decrypt"]);
        const plainBuffer = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv: nonce },
          cryptoKey,
          ciphertext
        );

        const decoder = new TextDecoder();
        const decrypted = JSON.parse(decoder.decode(plainBuffer));
        const prepared = decrypted.map((msg) => ({
          sender: msg.sender,
          fromMe: msg.sender === MY_NAME,
          text: msg.text,
          time: msg.time || "",
          date: msg.date || ""
        }));
        allMessages = prepared;
        playbackMessages = applyDateFilter(prepared, normalizedDate);
        populateDatePicker(allMessages, normalizedDate);
      } catch (err) {
        console.warn("Falling back to built-in messages:", err);
        allMessages = FALLBACK_MESSAGES;
        playbackMessages = FALLBACK_MESSAGES;
        populateDatePicker(allMessages, null);
      }
    }

    function getSenderBubbleColor(sender) {
      if (sender === MY_NAME) return null;
      if (!senderColors[sender]) {
        senderColors[sender] = COLOR_PALETTE[colorPointer % COLOR_PALETTE.length];
        colorPointer++;
      }
      return senderColors[sender];
    }

    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function formatMessageText(text) {
      if (!text) return "";
      const trimmed = text.trim().toLowerCase();
      if (trimmed === "image omitted") {
        return "üñºÔ∏è";
      }
      const escaped = escapeHtml(text).replace(/\n/g, "<br>");
      return escaped.replace(/(@[^\s<]+)/g, "<strong>$1</strong>");
    }

    function addMessage(msg) {
      const row = document.createElement("div");
      row.className = "bubble-row " + (msg.fromMe ? "me" : "them");

      const bubble = document.createElement("div");
      bubble.className = "bubble " + (msg.fromMe ? "me" : "them");
      if (!msg.fromMe) {
        const color = getSenderBubbleColor(msg.sender);
        if (color) {
          bubble.style.background = color;
          bubble.style.color = "#f8fafc";
          bubble.style.boxShadow = "0 4px 10px rgba(15, 23, 42, 0.45)";
        }
      }

      const sender = document.createElement("div");
      sender.className = "sender";
      sender.textContent = msg.sender;

      const text = document.createElement("div");
      const formatted = formatMessageText(msg.text);
      if (formatted === "üñºÔ∏è") {
        text.textContent = "üñºÔ∏è";
        text.style.fontSize = "20px";
      } else {
        text.innerHTML = formatted;
      }

      const time = document.createElement("div");
      time.className = "time";
      if (msg.time) time.textContent = msg.time;

      bubble.appendChild(sender);
      bubble.appendChild(text);
      bubble.appendChild(time);

      row.appendChild(bubble);
      chatEl.appendChild(row);

      // Scroll to bottom smoothly
      chatEl.scrollTo({
        top: chatEl.scrollHeight,
        behavior: "smooth"
      });
    }

    function step() {
      if (index >= playbackMessages.length) return;
      addMessage(playbackMessages[index]);
      index++;
    }

    // Tune these for pacing
    const INITIAL_DELAY_MS = 1200;
    const MESSAGE_INTERVAL_MS_MIN = 1800;
    const MESSAGE_INTERVAL_MS_MAX = 3200;

    function getNextMessageDelay() {
      const span = MESSAGE_INTERVAL_MS_MAX - MESSAGE_INTERVAL_MS_MIN;
      return MESSAGE_INTERVAL_MS_MIN + Math.random() * span;
    }

    function playNextMessage() {
      if (index >= playbackMessages.length) return;
      step();
      if (index < playbackMessages.length) {
        setTimeout(playNextMessage, getNextMessageDelay());
      }
    }

    async function startPlayback() {
      await loadMessages();
      if (!playbackMessages.length) return;

      setTimeout(() => {
        playNextMessage();
      }, INITIAL_DELAY_MS);
    }

    startPlayback();
  </script>
</body>
</html>
