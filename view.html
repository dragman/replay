<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chat Replay</title>
  <style>
    /* Basic page setup */
    body {
      margin: 0;
      padding: 0;
      background: #111827;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        sans-serif;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .app-container {
      width: 100%;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: clamp(10px, 3vw, 20px);
      box-sizing: border-box;
    }

    .phone-frame {
      width: min(100%, 420px);
      height: min(92vh, 720px);
      background: #020617;
      border-radius: clamp(16px, 4vw, 24px);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border: 2px solid #1e293b;
    }

    .top-bar {
      height: 54px;
      background: linear-gradient(90deg, #0f172a, #020617);
      display: flex;
      align-items: center;
      padding: 0 16px;
      color: #e5e7eb;
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 1px 0 rgba(15, 23, 42, 0.8);
      letter-spacing: 0.02em;
    }

    .top-bar .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      margin-right: 8px;
      background: #22c55e;
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.7);
    }

    .chat-window {
      flex: 1;
      padding: 14px 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      overflow-y: hidden; /* we'll scroll with JS */
      background: radial-gradient(circle at top, #0b1120 0, #020617 50%, #000 100%);
    }

    .bubble-row {
      display: flex;
      width: 100%;
      margin-bottom: 2px;
    }

    .bubble-row.them {
      justify-content: flex-start;
    }

    .bubble-row.me {
      justify-content: flex-end;
    }

    .bubble {
      max-width: 70%;
      padding: 8px 10px;
      border-radius: 16px;
      font-size: 13px;
      line-height: 1.35;
      position: relative;
      opacity: 0;
      transform: translateY(4px) scale(0.98);
      animation: bubbleIn 0.25s ease-out forwards;
    }

    .bubble.them {
      background: rgba(15, 23, 42, 0.95);
      color: #e5e7eb;
      border-bottom-left-radius: 4px;
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.6);
    }

    .bubble.me {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #052e16;
      border-bottom-right-radius: 4px;
      box-shadow: 0 4px 10px rgba(21, 128, 61, 0.5);
    }

    .status-message {
      color: #f1f5f9;
      text-align: center;
      font-size: 13px;
      padding: 24px;
      opacity: 0.85;
    }

    .control-bar {
      background: #030712;
      border-bottom: 1px solid rgba(15, 23, 42, 0.8);
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: #cbd5f5;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .control-bar label {
      opacity: 0.75;
    }

    .control-bar input[type="date"] {
      flex: 1;
      background: #0f172a;
      color: #e2e8f0;
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 999px;
      padding: 5px 12px;
      font-size: 12px;
      appearance: none;
    }

    .sender {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 2px;
      opacity: 1;
      color: rgba(248, 250, 252, 0.95);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.45);
    }

    .bubble.me .sender {
      color: #064e3b;
      text-shadow: none;
    }

    .time {
      font-size: 10px;
      opacity: 0.6;
      margin-top: 2px;
      text-align: right;
    }

    @keyframes bubbleIn {
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .bottom-bar {
      height: 40px;
      border-top: 1px solid rgba(15, 23, 42, 0.85);
      background: #020617;
      display: flex;
      align-items: center;
      padding: 0 14px;
      font-size: 11px;
      color: #4b5563;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .rec-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #16f978;
      margin-right: 8px;
      box-shadow: 0 0 10px rgba(249, 115, 22, 0.7);
    }

    /* Optional subtle vignette */
    .vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 80px rgba(0, 0, 0, 0.9);
      border-radius: 24px;
    }

    @media (max-width: 520px) {
      body {
        align-items: stretch;
      }

      .app-container {
        padding: 10px;
      }

      .phone-frame {
        width: 100%;
        height: 100vh;
        max-height: none;
        border-radius: 16px;
      }

      .control-bar {
        flex-wrap: wrap;
        gap: 6px;
        font-size: 10px;
      }

      .control-bar label {
        width: 100%;
      }

      .control-bar input[type="date"] {
        width: 100%;
      }

      .bubble {
        max-width: 100%;
      }

      .chat-window {
        padding: 12px 8px;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="phone-frame">
    <div class="top-bar">
      <div class="dot"></div>
      <span>Group Chat ¬∑ Replay</span>
    </div>
    <div class="control-bar">
      <label for="dateInput">Jump to date</label>
      <input type="date" id="dateInput" />
    </div>
    <div id="chat" class="chat-window"></div>
    <div class="bottom-bar">
      <div class="rec-dot"></div>
      <span>Chat playback</span>
    </div>
    <div class="vignette"></div>
  </div>

  <script>
    const MY_NAME = "Dragos"; // Change if you want a different sender marked as "me"
    const FALLBACK_MESSAGES = [
      {
        sender: "You",
        fromMe: true,
        text: "Hey, I finally exported the WhatsApp chat.",
        time: "09:12",
        date: "01/01/2020"
      },
      {
        sender: "Them",
        fromMe: false,
        text: "No way üòÇ how far back does it go?",
        time: "09:13",
        date: "01/01/2020"
      },
      {
        sender: "You",
        fromMe: true,
        text: "All the way to the very first awkward message.",
        time: "09:13",
        date: "01/01/2020"
      },
      {
        sender: "Them",
        fromMe: false,
        text: "We definitely don't talk about those.",
        time: "09:14",
        date: "01/01/2020"
      }
    ];

    const chatEl = document.getElementById("chat");
    const dateInputEl = document.getElementById("dateInput");
    let index = 0;
    let playbackMessages = FALLBACK_MESSAGES;
    let allMessages = FALLBACK_MESSAGES;
    const senderColors = {};
    const COLOR_PALETTE = [
      "#1d4ed8",
      "#7c3aed",
      "#db2777",
      "#f97316",
      "#0ea5e9",
      "#eab308",
      "#10b981",
      "#ec4899"
    ];
    let colorPointer = 0;

    const KEY_STORAGE_KEY = "chatReplayKey";
    const initialUrl = new URL(window.location.href);
    const initialSearchParams = new URLSearchParams(initialUrl.search);
    const initialHashString = initialUrl.hash.startsWith("#") ? initialUrl.hash.slice(1) : "";
    const initialHashParams = new URLSearchParams(initialHashString);
    const keyFromUrl = initialSearchParams.get("K") || initialHashParams.get("K") || "";
    let storedKey = "";
    try {
      storedKey = sessionStorage.getItem(KEY_STORAGE_KEY) || "";
    } catch (_) {
      storedKey = "";
    }
    const KEY_PARAM = keyFromUrl || storedKey || "";
    if (keyFromUrl) {
      try {
        sessionStorage.setItem(KEY_STORAGE_KEY, keyFromUrl);
      } catch (_) {
        // ignore storage issues
      }
    }

    if (initialSearchParams.has("K")) {
      initialSearchParams.delete("K");
    }
    const hashDate = initialHashParams.get("D");
    if (hashDate && !initialSearchParams.get("D")) {
      initialSearchParams.set("D", hashDate);
    }
    const sanitizedQuery = initialSearchParams.toString();
    if (initialUrl.search !== (sanitizedQuery ? `?${sanitizedQuery}` : "") || initialUrl.hash) {
      history.replaceState(null, "", initialUrl.pathname + (sanitizedQuery ? `?${sanitizedQuery}` : ""));
    }

    function base64ToBytes(b64) {
      const binary = atob(b64);
      const out = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        out[i] = binary.charCodeAt(i);
      }
      return out;
    }

    function base32ToBytes(str) {
      if (!str) throw new Error("Missing Base32 key");
      const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
      const clean = str.replace(/=+$/g, "").toUpperCase();
      let buffer = 0;
      let bitsLeft = 0;
      const out = [];

      for (const ch of clean) {
        const val = alphabet.indexOf(ch);
        if (val === -1) throw new Error("Invalid Base32 character");
        buffer = (buffer << 5) | val;
        bitsLeft += 5;
        if (bitsLeft >= 8) {
          bitsLeft -= 8;
          out.push((buffer >> bitsLeft) & 0xff);
        }
      }

      return new Uint8Array(out);
    }

    function normalizeDateInput(value) {
      if (!value) return null;
      const trimmed = value.trim();
      if (/^(\d{2})\/(\d{2})\/(\d{4})$/.test(trimmed)) {
        return trimmed;
      }
      const isoMatch = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (isoMatch) {
        const [, year, month, day] = isoMatch;
        return `${day}/${month}/${year}`;
      }
      return null;
    }

    function applyDateFilter(messages, normalizedDate) {
      if (!normalizedDate) {
        return messages;
      }
      const startIndex = messages.findIndex((msg) => msg.date === normalizedDate);
      if (startIndex === -1) {
        console.warn(`No messages found for date ${normalizedDate}`);
        return messages;
      }
      return messages.slice(startIndex);
    }

    function normalizedToISO(dateStr) {
      if (!dateStr) return "";
      const [day, month, year] = dateStr.split("/");
      if (!day || !month || !year) return "";
      return `${year}-${month.padStart(2, "0")}-${day.padStart(2, "0")}`;
    }

    function populateDatePicker(messages, selectedDate) {
      if (!dateInputEl) return;
      const dates = Array.from(
        new Set(
          messages
            .map((msg) => msg.date)
            .filter(Boolean)
        )
      );
      dates.sort((a, b) => {
        const [dayA, monthA, yearA] = a.split("/").map(Number);
        const [dayB, monthB, yearB] = b.split("/").map(Number);
        return new Date(yearA, monthA - 1, dayA) - new Date(yearB, monthB - 1, dayB);
      });

      if (dates.length) {
        const min = normalizedToISO(dates[0]);
        const max = normalizedToISO(dates[dates.length - 1]);
        dateInputEl.min = min;
        dateInputEl.max = max;
      }

      dateInputEl.value = selectedDate ? normalizedToISO(selectedDate) : "";
    }

    function shouldDelayDatePickerNavigation() {
      if (typeof window === "undefined") return false;
      try {
        if (window.matchMedia("(pointer: coarse)").matches) {
          return true;
        }
      } catch (_) {
        // ignore matchMedia issues
      }
      const ua = navigator.userAgent || "";
      return /iPad|iPhone|iPod|Android/i.test(ua);
    }

    const datePickerNeedsBlurCommit = shouldDelayDatePickerNavigation();

    function applyDateSelection(isoValue) {
      const url = new URL(window.location.href);
      url.searchParams.delete("K");
      if (isoValue) {
        url.searchParams.set("D", isoValue);
      } else {
        url.searchParams.delete("D");
      }
      window.location.href = url.pathname + (url.searchParams.toString() ? `?${url.searchParams}` : "");
    }

    function handleDateInputChange() {
      if (!dateInputEl) return;
      if (datePickerNeedsBlurCommit) {
        return;
      }
      applyDateSelection(dateInputEl.value);
    }

    function handleDateInputBlur() {
      if (!dateInputEl || !datePickerNeedsBlurCommit) return;
      applyDateSelection(dateInputEl.value);
    }

      if (dateInputEl) {
        dateInputEl.addEventListener("change", handleDateInputChange);
        if (datePickerNeedsBlurCommit) {
          dateInputEl.addEventListener("blur", handleDateInputBlur);
        }
      }

    function showStatusMessage(message) {
      if (!chatEl) return;
      chatEl.innerHTML = "";
      const status = document.createElement("div");
      status.className = "status-message";
      status.textContent = message;
      chatEl.appendChild(status);
    }

      async function gunzip(buffer) {
        if ("DecompressionStream" in window) {
          const ds = new DecompressionStream("gzip");
          const decompressedStream = new Blob([buffer]).stream().pipeThrough(ds);
          const decompressedBuffer = await new Response(decompressedStream).arrayBuffer();
          return decompressedBuffer;
        }
        console.warn("DecompressionStream unavailable; assuming plaintext payload");
        return buffer;
      }

    async function loadMessages() {
      try {
        if (!KEY_PARAM) {
          showStatusMessage("Missing decryption key. Scan the QR code again to continue.");
          playbackMessages = [];
          return;
        }
        const currentUrl = new URL(window.location.href);
        const dateFilterRaw = currentUrl.searchParams.get("D") || "";
        const normalizedDate = normalizeDateInput(dateFilterRaw);
        if (dateFilterRaw && !normalizedDate) {
          console.warn("Invalid date filter. Use DD/MM/YYYY or YYYY-MM-DD.");
        }
        const keyBytes = base32ToBytes(KEY_PARAM);

        const response = await fetch("chat_data.enc");
        if (!response.ok) {
          throw new Error(`Failed to fetch chat_data.enc (${response.status})`);
        }
        const enc = await response.json();
        if (enc.expires) {
          const expiresAt = new Date(enc.expires);
          if (Number.isNaN(expiresAt.getTime())) {
            console.warn("Invalid expiry metadata:", enc.expires);
          } else {
            const now = new Date();
            if (now > expiresAt) {
              showStatusMessage(`This key expired on ${expiresAt.toDateString()}. Request a new QR code to unlock the chat.`);
              playbackMessages = [];
              return;
            }
          }
        }
        const nonce = base64ToBytes(enc.nonce);
        const ciphertext = base64ToBytes(enc.ciphertext);

        const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, "AES-GCM", false, ["decrypt"]);
        const plainBuffer = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv: nonce },
          cryptoKey,
          ciphertext
        );

        const decompressed = await gunzip(plainBuffer);
        const decoder = new TextDecoder();
        const decrypted = JSON.parse(decoder.decode(decompressed));
        const prepared = decrypted.map((msg) => ({
          sender: msg.sender,
          fromMe: msg.sender === MY_NAME,
          text: msg.text,
          time: msg.time || "",
          date: msg.date || ""
        }));
        allMessages = prepared;
        playbackMessages = applyDateFilter(prepared, normalizedDate);
        populateDatePicker(allMessages, normalizedDate);
      } catch (err) {
        console.warn("Falling back to built-in messages:", err);
        allMessages = FALLBACK_MESSAGES;
        playbackMessages = FALLBACK_MESSAGES;
        populateDatePicker(allMessages, null);
      }
    }

    function getSenderBubbleColor(sender) {
      if (sender === MY_NAME) return null;
      if (!senderColors[sender]) {
        senderColors[sender] = COLOR_PALETTE[colorPointer % COLOR_PALETTE.length];
        colorPointer++;
      }
      return senderColors[sender];
    }

    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function formatMessageText(text) {
      if (!text) return "";
      const trimmed = text.trim().toLowerCase();
      // mirror WhatsApp placeholders with concise emoji
      if (trimmed === "image omitted") return "üñºÔ∏è";
      if (trimmed === "gif omitted") return "üéûÔ∏è";
      if (trimmed === "sticker omitted") return "üè∑Ô∏è";
      const escaped = escapeHtml(text).replace(/\n/g, "<br>");
      return escaped.replace(/(@[^\s<]+)/g, "<strong>$1</strong>");
    }

    function addMessage(msg) {
      const row = document.createElement("div");
      row.className = "bubble-row " + (msg.fromMe ? "me" : "them");

      const bubble = document.createElement("div");
      bubble.className = "bubble " + (msg.fromMe ? "me" : "them");
      if (!msg.fromMe) {
        const color = getSenderBubbleColor(msg.sender);
        if (color) {
          bubble.style.background = color;
          bubble.style.color = "#f8fafc";
          bubble.style.boxShadow = "0 4px 10px rgba(15, 23, 42, 0.45)";
        }
      }

      const sender = document.createElement("div");
      sender.className = "sender";
      sender.textContent = msg.sender;

      const text = document.createElement("div");
      const formatted = formatMessageText(msg.text);
      if (formatted === "üñºÔ∏è") {
        text.textContent = "üñºÔ∏è";
        text.style.fontSize = "20px";
      } else {
        text.innerHTML = formatted;
      }

      const time = document.createElement("div");
      time.className = "time";
      if (msg.time) time.textContent = msg.time;

      bubble.appendChild(sender);
      bubble.appendChild(text);
      bubble.appendChild(time);

      row.appendChild(bubble);
      chatEl.appendChild(row);

      // Scroll to bottom smoothly
      chatEl.scrollTo({
        top: chatEl.scrollHeight,
        behavior: "smooth"
      });
    }

    function step() {
      if (index >= playbackMessages.length) return;
      addMessage(playbackMessages[index]);
      index++;
    }

    // Tune these for pacing
    const INITIAL_DELAY_MS = 1200;
    const MESSAGE_INTERVAL_MS_MIN = 1800;
    const MESSAGE_INTERVAL_MS_MAX = 3200;

    function getNextMessageDelay() {
      const span = MESSAGE_INTERVAL_MS_MAX - MESSAGE_INTERVAL_MS_MIN;
      return MESSAGE_INTERVAL_MS_MIN + Math.random() * span;
    }

    function playNextMessage() {
      if (index >= playbackMessages.length) return;
      step();
      if (index < playbackMessages.length) {
        setTimeout(playNextMessage, getNextMessageDelay());
      }
    }

    async function startPlayback() {
      await loadMessages();
      if (!playbackMessages.length) return;

      setTimeout(() => {
        playNextMessage();
      }, INITIAL_DELAY_MS);
    }

    startPlayback();
  </script>
</body>
</html>
